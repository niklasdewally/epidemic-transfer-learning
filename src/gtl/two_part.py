"""
Functions to generate "two-part" graphs.

These include, in particular:
  * modular graphs consisting of two modules of different distributions.
  * core-periphery graphs.


See `two_part_graph_generator` for generic details.
"""

from typing import TypeAlias, Callable
from collections.abc import Iterator
import random as rng
import networkx as nx

GraphJoiner: TypeAlias = Callable[[nx.Graph, nx.Graph], nx.Graph]

def two_part_graph_generator(
    g1s: Iterator[nx.Graph],
    g2s: Iterator[nx.Graph],
    join_graphs: GraphJoiner,
) -> Iterator[nx.Graph]:
    """
    A generator that creates two part graphs (graphs formed by joining
    two graphs with different distributions according to a given algorithm).

    For example, a core-periphery graph could be generated by joining a core
    and periphery graph with edges with similiar density to the periphery.

    Nodes are marked with their graph of origin (1 or 2) in the origin
    attribute.

    Join Function
    ==============

    The following behaviours must be obeyed in any given join function:

        * All node and edge atrributes from both generated graphs must be
          preserved, where the nodes/edges still exist.

    For an example join function, see `join_core_periphery`.

    Return Value
    ============

    The returned iterator will generate graphs infinitely, or until either of
    the input iterators are exhaused.
    """

    while True:
        g1 = next(g1s)
        g2 = next(g2s)

        # label all nodes with their origins
        for n in g1.nodes():
            g1.nodes[n]["origin"] = 1
        for m in g2.nodes():
            g2.nodes[m]["origin"] = 2

        modular_graph = join_graphs(g1, g2)

        # find and return largest connected component
        lcc = modular_graph.subgraph(max(nx.connected_components(modular_graph),key=len)).copy()
        lcc = nx.convert_node_labels_to_integers(lcc)
        yield lcc


def join_core_periphery(g_core: nx.Graph, g_periphery: nx.Graph) -> nx.Graph:
    """
    Join a core and a periphery graph together to form a core-periphery graph.

    The core is joined to the periphery by attaching edges from core to
    periphery such that these new edges have a similar density as the periphery.

    When using with `two_part_graph_generator`, it is expected that g1s 
    generates the core, and g2s generates the periphery.
    """

    # With thanks to Simon Dobson and Peter Mann.
    # (https://github.com/simoninireland/epydemic/blob/master/epydemic/coreperiphery_generator.py#L29)

    # renumber nodes to be 0-n = core, n-m = periphery
    g_core = nx.convert_node_labels_to_integers(g_core)
    g_periphery = nx.convert_node_labels_to_integers(g_periphery,first_label=g_core.number_of_nodes())
    g = nx.compose(g_core, g_periphery)

    # join the periphery to the core using the same density
    # as within the periphery itself

    periphery_density = nx.density(g_periphery)
    for n in g_core.nodes():
        for m in g_periphery.nodes():
            if rng.random() <= periphery_density:
                g.add_edge(n, m)

    return g
